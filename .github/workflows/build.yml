name: Build and Deploy UwU Converter

on:
  push:
    branches: [ master ]

env:
  # Repository-specific variables (non-sensitive)
  IMAGE_NAME: uwu-converter
  DOCKERFILE_PATH: ./src/Dockerfile
  GITOPS_REPO: Demonslyr/atriarch-argo-state  # GitOps repository
  GITOPS_BRANCH: production
  DEPLOYMENT_YAML_PATH: uwu-converter/uwu-converter.yaml  # Path to deployment YAML
  # Kubernetes secret names
  K8S_SECRET_NAME: github-actions-secrets
  K8S_SECRET_NAMESPACE: actions-runner-system

jobs:
  test:
    runs-on: [self-hosted, arc-pi]  # Organization-level runners
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Buildx for testing
      uses: docker/setup-buildx-action@v3
      with:
        driver: kubernetes
        driver-opts: |
          namespace=actions-runner-system
          serviceaccount=buildx
          nodeselector=kubernetes.io/arch=arm64
          qemu.install=true
        install: true
    
    - name: Load secrets from Kubernetes
      run: |
        # Extract secrets and immediately mask them before setting env vars
        DOCKER_REGISTRY_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-registry}' | base64 -d)
        DOCKER_USERNAME_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-username}' | base64 -d)
        DOCKER_PASSWORD_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-password}' | base64 -d)
        NUGET_USERNAME_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.nuget-username}' | base64 -d)
        NUGET_PASSWORD_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.nuget-password}' | base64 -d)
        
        # Mask the values IMMEDIATELY before they can be logged
        echo "::add-mask::$DOCKER_REGISTRY_VAL"
        echo "::add-mask::$DOCKER_USERNAME_VAL"
        echo "::add-mask::$DOCKER_PASSWORD_VAL"
        echo "::add-mask::$NUGET_USERNAME_VAL"
        echo "::add-mask::$NUGET_PASSWORD_VAL"
        
        # Now safely set environment variables
        echo "DOCKER_REGISTRY=$DOCKER_REGISTRY_VAL" >> $GITHUB_ENV
        echo "DOCKER_USERNAME=$DOCKER_USERNAME_VAL" >> $GITHUB_ENV
        echo "DOCKER_PASSWORD=$DOCKER_PASSWORD_VAL" >> $GITHUB_ENV
        echo "NUGET_USERNAME=$NUGET_USERNAME_VAL" >> $GITHUB_ENV
        echo "NUGET_PASSWORD=$NUGET_PASSWORD_VAL" >> $GITHUB_ENV
    
    - name: Log in to Docker Registry (for private base images/packages)
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_PASSWORD }}
    
    - name: Build and run tests in container
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ env.DOCKERFILE_PATH }}
        target: build  # Stop at the build stage to run tests
        platforms: linux/amd64
        push: false
        build-args: |
          NUGET_USER=${{ env.NUGET_USERNAME }}
          NUGET_PASS=${{ env.NUGET_PASSWORD }}
        outputs: type=cacheonly
    
    - name: Run tests in built container
      run: |
        # Create a test container from the build stage
        docker buildx build \
          --target build \
          --platform linux/amd64 \
          --build-arg NUGET_USER=${{ env.NUGET_USERNAME }} \
          --build-arg NUGET_PASS=${{ env.NUGET_PASSWORD }} \
          --load \
          --tag test-image \
          -f ${{ env.DOCKERFILE_PATH }} .
        
        # Run tests in the container
        docker run --rm \
          --workdir /src \
          test-image \
          dotnet test ../UwUConverter.Test/UwUConverter.Tests.csproj --logger "console;verbosity=detailed"

  build-and-push:
    needs: test
    runs-on: [self-hosted, arc-pi]  # Organization-level runners
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Load secrets from Kubernetes
      run: |
        # Extract secrets and immediately mask them
        DOCKER_REGISTRY_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-registry}' | base64 -d)
        DOCKER_USERNAME_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-username}' | base64 -d)
        DOCKER_PASSWORD_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-password}' | base64 -d)
        NUGET_USERNAME_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.nuget-username}' | base64 -d)
        NUGET_PASSWORD_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.nuget-password}' | base64 -d)
        
        # Mask the values IMMEDIATELY
        echo "::add-mask::$DOCKER_REGISTRY_VAL"
        echo "::add-mask::$DOCKER_USERNAME_VAL"
        echo "::add-mask::$DOCKER_PASSWORD_VAL"
        echo "::add-mask::$NUGET_USERNAME_VAL"
        echo "::add-mask::$NUGET_PASSWORD_VAL"
        
        # Set environment variables
        echo "DOCKER_REGISTRY=$DOCKER_REGISTRY_VAL" >> $GITHUB_ENV
        echo "DOCKER_USERNAME=$DOCKER_USERNAME_VAL" >> $GITHUB_ENV
        echo "DOCKER_PASSWORD=$DOCKER_PASSWORD_VAL" >> $GITHUB_ENV
        echo "NUGET_USERNAME=$NUGET_USERNAME_VAL" >> $GITHUB_ENV
        echo "NUGET_PASSWORD=$NUGET_PASSWORD_VAL" >> $GITHUB_ENV
    
    - name: Set up Buildx (k8s driver + qemu)
      uses: docker/setup-buildx-action@v3
      with:
        driver: kubernetes
        driver-opts: |
          namespace=actions-runner-system
          serviceaccount=buildx
          nodeselector=kubernetes.io/arch=arm64
          qemu.install=true
        install: true
    
    - name: Log in to Docker Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_PASSWORD }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=raw,value=v1.0.${{ github.run_number }}
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ env.DOCKERFILE_PATH }}
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          NUGET_USER=${{ env.NUGET_USERNAME }}
          NUGET_PASS=${{ env.NUGET_PASSWORD }}

  update-gitops:
    needs: build-and-push
    runs-on: [self-hosted, arc-pi]  # Organization-level runners
    if: github.ref == 'refs/heads/master'
    
    steps:
    - name: Load secrets from Kubernetes
      run: |
        # Extract GitOps token and registry
        GITOPS_TOKEN_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.gitops-token}' | base64 -d)
        DOCKER_REGISTRY_VAL=$(kubectl get secret ${{ env.K8S_SECRET_NAME }} -n ${{ env.K8S_SECRET_NAMESPACE }} -o jsonpath='{.data.docker-registry}' | base64 -d)
        
        # Mask the values IMMEDIATELY
        echo "::add-mask::$GITOPS_TOKEN_VAL"
        echo "::add-mask::$DOCKER_REGISTRY_VAL"
        
        # Set environment variables
        echo "GITOPS_TOKEN=$GITOPS_TOKEN_VAL" >> $GITHUB_ENV
        echo "DOCKER_REGISTRY=$DOCKER_REGISTRY_VAL" >> $GITHUB_ENV
    
    - name: Checkout GitOps Repository
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO }}
        ref: ${{ env.GITOPS_BRANCH }}
        token: ${{ env.GITOPS_TOKEN }}
        path: gitops
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Install PyYAML
      run: pip install PyYAML
    
    - name: Update deployment YAML
      run: |
        cat << 'EOF' > update_yaml.py
        import yaml
        import sys
        import os
        
        deployment_path = os.path.join('gitops', '${{ env.DEPLOYMENT_YAML_PATH }}')
        image_name = '${{ env.IMAGE_NAME }}'
        new_image = '${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:v1.0.${{ github.run_number }}'
        
        print(f'Updating {deployment_path} with image: {new_image}')
        
        documents = []
        found_image = False
        
        with open(deployment_path, 'r') as file:
            for doc in yaml.safe_load_all(file):
                if doc and doc.get('kind') == 'Deployment' and doc.get('metadata', {}).get('name') == image_name:
                    containers = doc.get('spec', {}).get('template', {}).get('spec', {}).get('containers', [])
                    for container in containers:
                        if 'image' in container:
                            container['image'] = new_image
                            found_image = True
                            print(f'Updated container image to: {new_image}')
                documents.append(doc)
        
        if not found_image:
            print(f'Warning: No image found for deployment {image_name}')
            sys.exit(1)
        
        with open(deployment_path, 'w') as file:
            yaml.safe_dump_all(documents, file, explicit_start=True, default_flow_style=False)
        
        print('Successfully updated deployment YAML')
        EOF
        
        python update_yaml.py
    
    - name: Commit and push changes
      run: |
        cd gitops
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add ${{ env.DEPLOYMENT_YAML_PATH }}
        git commit -m "Update ${{ env.IMAGE_NAME }} to v1.0.${{ github.run_number }}"
        git push
